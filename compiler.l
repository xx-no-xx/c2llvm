D			[0-9]
L			[a-zA-Z_]
H			[a-fA-F0-9]
E			[Ee][+-]?{D}+
FS			(f|F|l|L)
IS			(u|U|l|L)* 


/* 上方是一些便于正则表达式的定义，D指数字，L指字母？，H指十六进制可能用到的东西，E指表达式，*/

%{
#include <cstdio> // 因为在此处使用了printf
#include <cstdlib>
#include <string>
#include <iostream>
#include "ast.h"
#include "generator.h"
#include "y.tab.hpp" // generated by YACC
using namespace std;

#define MAX_STR_VALUE 100
#define MAX_TYPE_NAME 100

void TESTONLY();
void save_type(std::string str);
void save_value(std::string str);

%}

%%
"..."		{ save_type("VARARG"); return VARARG; }
"extern"	{ save_type("EXTERN"); return EXTERN; }

"+"         { save_type("TADD"); return TADD;}
"-"         { save_type("TSUB"); return TSUB;}
"*"         { save_type("TMUL"); return TMUL;}
"/"         { save_type("TDIV"); return TDIV;}
"%"         { save_type("TMOD"); return TMOD;}
"<<"        { save_type("TLSFT"); return TLSFT;}
">>"        { save_type("TRSFT"); return TRSFT;}
"|"         { save_type("TBIT_OR"); return TBIT_OR;}
"&"         { save_type("TBIT_AND"); return TBIT_AND;}
"^"         { save_type("TBIT_XOR"); return TBIT_XOR;}
"!"         { save_type("TBIT_NOT"); return TBIT_NOT;}

"&&"        { save_type("TAND"); return TAND;}
"||"        { save_type("TOR"); return TOR;}
"=" 		{ save_type("ASSIGN"); return ASSIGN; } // 赋值=号
"=="        { save_type("TCEQ"); return TCEQ;}
"!="        { save_type("TCNE"); return TCNE;}
"<"         { save_type("TCLT"); return TCLT;}
"<="        { save_type("TCLE"); return TCLE;}
">"         { save_type("TCGT"); return TCGT;}
">="        { save_type("TCGE"); return TCGE;}

"("         { save_type("TLPAREN"); return TLPAREN;}
")"         { save_type("TRPAREN"); return TRPAREN;}
"["         { save_type("TLBRACKET"); return TLBRACKET;}
"]"         { save_type("TRBRACKET"); return TRBRACKET;}
"{"         { save_type("TLBRACE"); return TLBRACE;}
"}"         { save_type("TRBRACE"); return TRBRACE;}

","         { save_type("TCOMMA"); return TCOMMA;}
"."         { save_type("TDOT"); return TDOT;}
";" 		{ save_type("SEMICOLON"); return SEMICOLON; }  // 分号;

"if"		{ save_type("IF"); return IF; }
"else"		{ save_type("ELSE"); return ELSE; }
"while"		{ save_type("WHILE"); return WHILE; }
"for"		{ save_type("FOR"); return FOR; }
"break"		{ save_type("BREAK"); return BREAK; }
"continue"	{ save_type("CONTINUE"); return CONTINUE; }
"return"	{ save_type("RETURN"); return RETURN; }

"int" 		{ save_type("INT"); return INT; } // int标识符
"char"		{ save_type("CHAR"); return CHAR; }
"double"	{ save_type("DOUBLE"); return FLOAT; }
"float"	{ save_type("FLOAT"); return FLOAT; }
"void"		{ save_type("VOID"); return VOID; }
"char*"		{ save_type("CHAR_PTR"); return CHAR_PTR;}

{D}+ 		{ save_value("INT_CONSTANT"); return INT_CONSTANT; } 

'(\\.|[^\\'])' {
    // save_type("CHAR_LITERAL");
    yylval.char_value = new std::string(yytext);
	std::cout << "char: " << yytext << std::endl; // debug用
    return CHAR_CONSTANT;
}	// 字符

\"(\\.|[^\\"])*\" {
	std::cout << "string: " << yytext << std::endl;
	yylval.str_value = new std::string(yytext);
	std::cout << "string: " << *yylval.str_value << std::endl;
	yylval.str_value->erase(remove(yylval.str_value->begin(), yylval.str_value->end(), '"'), yylval.str_value->end()); 
  std::string::size_type pos = 0;
	std::string sub_str = {R"(\n)"};
	std::string rep_str = {"\n"};
  while((pos = yylval.str_value->find(sub_str)) != std::string::npos)  {
      yylval.str_value->replace(pos, sub_str.length(), rep_str);
  }
	std::cout << "string: " << *yylval.str_value << std::endl;
	return STR_CONSTANT;
}

{L}({L}|{D})* { save_value("IDENTIFIER"); return IDENTIFIER; }

([1-9][0-9]*)|0|([0-9]+\.[0-9]*) {
    float temp;
    sscanf(yytext, "%f", &temp);
    yylval.float_value = temp;
    return FLOAT_CONSTANT;
} // double型

[ \t\v\f] 
. {
    fprintf(stderr, "lexical error.\n");
    exit(1);
}
%%

// save_type: 保存这个变量的类型，到yylval.type
// 	yylval.type = new std::string(str);
void save_type(std::string str) {
	return;
}

// save_value: 对于形如321这样的常数变量，通过str制定它被保存的value应该如何解析
void save_value(std::string str) { 
	if(str == "INT_CONSTANT") {
		yylval.int_value = atoi(yytext);
	}
	else if(str == "IDENTIFIER") {
		yylval.str_value = new std::string(yytext);
	}
	return;
}

void TESTONLY(void) {
	std::cout << "INT:" << yytext << std::endl;
	return;
}

int yywrap(void) {
	return 1;
}
